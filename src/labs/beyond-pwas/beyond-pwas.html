<link rel="import" href="../../../bower_components/polymer/polymer.html">

<link rel="import" href="../../../bower_components/iron-icons/iron-icons.html">
<link rel="import" href="../../../bower_components/paper-button/paper-button.html">
<link rel="import" href="../../../bower_components/codelab-components/google-codelab-elements.html">

<dom-module id="codelab-beyond-pwas">
    <template>
        <google-codelab title="Beyond PWAs"
                        feedback-link="https://github.com/The-Guide/fe-guild-2019-pwa-code-labs/issues"
                        environment="web"
                        last-updated="2019-01-29">
            <google-codelab-step label="Introduction" duration="1">
                <p>
                    Modern browsers are capable of some amazing things: access to hardware features such as the user’s
                    geolocation, device vibration, and even battery status is already available via easy-to-access
                    APIs.
                    It doesn't end there, either. More APIs are currently being developed that will give web developers
                    even greater access to device hardware. Modern browser vendors are working on ways to use the
                    hardware features of a device to allow developers even greater access to hardware capabilities.
                    Near Field Communication (NFC), ambient light sensors, proximity sensors, accelerometers, and even
                    shape detection are being targeted by some of the amazing APIs currently being developed.
                </p>

                <p>
                    If you're looking to build a powerful PWA that takes advantage of the hardware on a device, things
                    are only going to get better. Native apps have had access to these features for many years, so it's
                    great to see this kind of thing coming to the web.
                </p>

                <h2>
                    <strong>What You'll Learn</strong>
                </h2>

                <ul class="checklist">
                    <li>Camera & Microphone</li>
                    <li>Geolocation</li>
                    <li>Web Streams API</li>
                    <li>Web Bluetooth API</li>
                    <li>Web Share API</li>
                    <li>Payment Request API</li>
                    <li>Shape Detection API</li>
                </ul>
            </google-codelab-step>
            <google-codelab-step label="Getting set up" duration="3">
                <h2>Project Set Up</h2>

                <p>
                    In this code lab, we are building on top of the project started in the
                    <code>Web Push Notifications</code> code lab.
                </p>

                <p>
                    If you didn't do it already: <strong>Fork</strong> and then <strong>Clone</strong> the following
                    repository: <code>https://github.com/The-Guide/fe-guild-2019-pwa.git</code>
                </p>

                <pre>
<code>
$ git clone https://github.com/[YOUR GITHUB PROFILE]/fe-guild-2019-pwa.git
$ cd fe-guild-2019-pwa
</code></pre>

                <p>
                    If you want to start directly with <code>Beyond PWAs</code> checkout the following
                    branch:
                </p>

                <pre><code>$ git checkout pwa-beyound-init</code></pre>

                <p>First install the dependencies</p>

                <pre><code>$ npm install</code></pre>

                <p>Then type in the terminal</p>

                <pre><code>$ npm start</code></pre>

                <p>and open Chrome at <code>localhost:8080fe-guild-2019-pwa/</code></p>

                <p>
                    In this code lab, we are also using the server so in case you didn't do it already
                    <strong>fork</strong> and then <strong>clone</strong> the following
                    repository: <code>https://github.com/The-Guide/fe-guild-2019-pwa-server.git</code>
                </p>

                <pre>
<code>
$ git clone https://github.com/[YOUR GITHUB PROFILE]/fe-guild-2019-pwa-server.git
$ cd fe-guild-2019-pwa-server
</code></pre>
                <p>Install dependencies</p>

                <pre><code>$ npm install</code></pre>

                <p>
                    To start the project type in the terminal:
                </p>

                <pre><code>$ npm start</code></pre>

                <p>the server will be hosted at <code>localhost:3000</code></p>
            </google-codelab-step>
            <google-codelab-step label="Camera & Microphone" duration="15">
                <p>
                    The <strong>Media Capture API</strong> allows authorized Web applications to access the streams from
                    the device's audio and video capturing interfaces, i.e. to use the data available from the camera
                    and the microphone. The streams exposed by the API can be bound directly to the HTML
                    <code>&lt;audio&gt;</code> or <code>&lt;video&gt;</code> elements or read and manipulated in the
                    code, including further more specific processing via <strong>Image Capture API</strong>, <strong>Media
                    Recorder API</strong> or <strong>Real-Time Communication</strong>.
                </p>

                <p>
                    There is also a higher level alternative built-in into mobile operating systems like iOS and Android
                    that doesn't require any JavaScript API - the basic HTML <code>&lt;input type="file"
                    accept="image/*"&gt;</code> element allows launching any application that provides an image
                    file, including the camera.
                </p>

                <h2>API glimpse</h2>

                <ul>
                    <li>
                        <pre><code>navigator.mediaDevices.getUserMedia(constraints)</code></pre>
                        <p>
                            Prompts the user for access to the media interface specified by the <code>constraints</code>
                            and returns a <code>Promise</code> that is resolved with the interface's stream handler.
                        </p>
                    </li>
                    <li>
                        <pre><code>stream.getAudioTracks()</code></pre>
                        <p>Returns a collection of audio tracks objects being provided by the device's microphone.</p>
                    </li>

                    <li>
                        <pre><code>stream.getVideoTracks()</code></pre>
                        <p>Returns a collection of video tracks objects being provided by the device's camera.</p>
                    </li>

                    <li>
                        <pre><code>mediaElement.srcObject = stream</code></pre>
                        <p>
                            Sets a stream to be rendered into the provided <code>&lt;audio&gt;</code> or
                            <code>&lt;video&gt;</code> DOM element.
                        </p>
                    </li>
                </ul>

                <p>
                    Previous version of the standard, supported with vendor prefixes, contained the callback-based
                    <code>getUserMedia</code> method directly within the <code>navigator</code> element:
                </p>

                <pre><code>navigator.webkitGetUserMedia(constraints, successCallback, errorCallback)</code></pre>

                <h2>Adapting the Progressive Selfies app</h2>

                <p>
                    The <code>Media Capture API</code> is what we need to capture selfies instead of uploading a picture
                </p>

                <h3>In <code>index.html</code></h3>

                <p>
                    Just above the <code>div#pick-image</code>
                </p>

                <pre>
<code>
&lt;video id="player" autoplay&gt;&lt;/video&gt;
&lt;canvas id="canvas" width="320px" height="240px"&gt;&lt;/canvas&gt;
&lt;button
    id="capture-btn"
    class="mdl-button mdl-js-button mdl-button--raised mdl-button--colored"&gt;
    Capture
&lt;/button&gt;
</code></pre>
                <h3>In <code>feed.css</code></h3>

                <p>Just after <code>#create-post</code></p>

                <pre>
<code>
#create-post video, #create-post canvas {
    width: 512px;
    max-width: 100%;
    display: none;
    margin: auto;
}

#create-post #pick-image, #create-post #location-loader {
    display: none;
}

#create-post #capture-btn {
    margin: 10px auto;
}
</code></pre>
                <h3>In <code>feed.js</code></h3>

                <p>Just after the declaration of <code>imagePicker</code></p>

                <pre>
<code>
const imagePickerArea = document.querySelector('#pick-image');
const videoPlayer = document.querySelector('#player');
const canvasElement = document.querySelector('#canvas');
const captureButton = document.querySelector('#capture-btn');
</code></pre>
                <p>Just after the last variable declaration</p>

                <pre>
<code>
const initializeMedia = () => {
    if (!('mediaDevices' in navigator)) {
        navigator.mediaDevices = {};
    }

    if (!('getUserMedia' in navigator.mediaDevices)) {
        navigator.mediaDevices.getUserMedia = (constraints) => {
            const getUserMedia = navigator.webkitGetUserMedia || navigator.mozGetUserMedia;

            if (!getUserMedia) {
                return Promise.reject(new Error('getUserMedia is not implemented!'));
            }

            return new Promise((resolve, reject) => getUserMedia.call(navigator, constraints, resolve, reject));
        };
    }

    navigator.mediaDevices.getUserMedia({video: { facingMode: 'user'}, audio: false})
        .then(stream => {
            videoPlayer.srcObject = stream;
            videoPlayer.style.display = 'block';
            videoPlayer.setAttribute('autoplay', '');
            videoPlayer.setAttribute('muted', '');
            videoPlayer.setAttribute('playsinline', '');
        })
        .catch(error => {
            console.log(error);
            imagePickerArea.style.display = 'block';
        });
};
</code></pre>
                <p>
                    Adapt <code>openCreatePostModal</code> by replacing the first line with
                </p>

                <pre>
<code>
setTimeout(() => createPostArea.style.transform = 'translateY(0)', 1);
initializeMedia();
</code></pre>
                <p>Replace <code>closeCreatePostModal</code> with</p>

                <pre>
<code>
const closeCreatePostModal = () => {
    imagePickerArea.style.display = 'none';
    videoPlayer.style.display = 'none';
    canvasElement.style.display = 'none';
    captureButton.style.display = 'inline';
    if (videoPlayer.srcObject) {
        videoPlayer.srcObject.getVideoTracks().forEach(track => track.stop());
    }
    setTimeout(() => createPostArea.style.transform = 'translateY(100vh)', 1);
};
</code></pre>
                <p>Add a <code>click</code> event handler for <code>captureButton</code></p>

                <pre>
<code>
captureButton.addEventListener('click', event => {
    canvasElement.style.display = 'block';
    videoPlayer.style.display = 'none';
    captureButton.style.display = 'none';
    const context = canvasElement.getContext('2d');
    context.drawImage(
        videoPlayer, 0, 0, canvasElement.width, videoPlayer.videoHeight / (videoPlayer.videoWidth / canvasElement.width)
    );
    videoPlayer.srcObject.getVideoTracks().forEach(track => track.stop());
    picture = dataURItoBlob(canvasElement.toDataURL());
});
</code></pre>
                <h3>In <code>utility.js</code></h3>

                <pre>
<code>
const dataURItoBlob= dataURI => {
    const byteString = atob(dataURI.split(',')[1]);
    const mimeString = dataURI.split(',')[0].split(':')[1].split(';')[0];
    const ab = new ArrayBuffer(byteString.length);
    const ia = new Uint8Array(ab);
    for (let i = 0; i < byteString.length; i++) {
        ia[i] = byteString.charCodeAt(i);
    }
    const blob = new Blob([ab], {type: mimeString});
    return blob;
};
</code></pre>
                <h3>Testing</h3>

                <p>
                    Don't forget to run <code>npm run build</code> before <code>npm start</code> in order for the
                    service
                    worker to take into account the latest changes to the files
                </p>

                <p>
                    Testing on mobile requires <code>https</code> so you need to deploy it to <strong>GitHub
                    Pages</strong> (have a look at the <em>Introduction to Service Workers</em> step 4 <em>Add to Home
                    Screen</em> if you don't have it set up) so run <code>npm run deploy</code>
                </p>

                <h2>Resources</h2>

                <ul>
                    <li>
                        <a href="https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices">
                            Media Devices
                        </a>
                    </li>
                    <li>
                        <a href="https://developer.mozilla.org/en-US/docs/Web/API/ImageCapture">
                            Image Capture
                        </a>
                    </li>
                    <li>
                        <a href="https://developer.mozilla.org/en-US/docs/Web/API/MediaStream_Recording_API">
                            MediaStream Recording API
                        </a>
                    </li>
                    <li>
                        <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API">
                            WebRTC API
                        </a>
                    </li>
                </ul>
            </google-codelab-step>
            <google-codelab-step label="Geolocation" duration="15">
                <p>
                    The <strong>Geolocation API</strong> lets authorized Web applications to access the location data
                    provided by the device - obtained using either GPS or from the network environment. Apart from the
                    one-off location query, it also provides a way for the app to be notified about the location
                    changes.
                </p>

                <h2>API glimpse</h2>

                <ul>
                    <li>
                        <pre><code>navigator.geolocation.getCurrentPosition(callback)</code></pre>
                        <p>
                            Runs one-off query for the location with coordinates, accuracy, altitude & speed, if
                            available.
                        </p>
                    </li>
                    <li>
                        <pre><code>navigator.geolocation.watchPosition(callback)</code></pre>
                        <p>
                            Sets up observing for location changes, invoking callback for every change.
                        </p>
                    </li>
                </ul>

                <h2>Adapting the Progressive Selfies app</h2>

                <p>
                    Let's use the <strong>Geolocation API</strong> to get our position when we take selfies
                </p>

                <h3>In <code>index.html</code></h3>

                <p>
                    Just below the <code>div#manual-location</code>
                </p>

                <pre>
<code>
&lt;div class="input-section"&gt;
    &lt;button
        id="location-btn"
        type="button"
        class="mdl-button mdl-js-button mdl-button mdl-button--colored"&gt;
        Get Location
    &lt;/button&gt;
    &lt;div
        id="location-loader"
        class="mdl-spinner mdl-js-spinner is-active"&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></pre>
                <h3>In <code>feed.css</code></h3>

                <pre>
<code>
.mdl-spinner {
  margin: auto;
}
</code></pre>
                <h3>In <code>feed.js</code></h3>

                <p>After the last variable declaration</p>

                <pre>
<code>
const locationButton = document.querySelector('#location-btn');
const locationLoader = document.querySelector('#location-loader');
let fetchedLocation = {lat: 0, lng: 0};
</code></pre>
                <p>Just before <code>initializeMedia</code></p>

                <pre>
<code>
const initializeLocation = () => {
    if (!('geolocation' in navigator)) {
        locationButton.style.display = 'none';
    }
};
</code></pre>
                <p>
                    Adapt <strong>openCreatePostModal</strong> by adding the call to <code>initializeLocation();</code>
                    after the call to <code>initializeMedia();</code>
                </p>

                <p>
                    Adapt <strong>closeCreatePostModal</strong> by adding the following before the <code>if</code> block
                </p>

                <pre>
<code>
locationButton.style.display = 'inline';
locationLoader.style.display = 'none';
</code></pre>
                <p>Add a <code>click</code> event handler for <code>locationButton</code></p>

                <pre>
<code>
   locationButton.addEventListener('click', event => {
    if (!('geolocation' in navigator)) {
        return;
    }
    let sawAlert = false;

    locationButton.style.display = 'none';
    locationLoader.style.display = 'block';

    navigator.geolocation.getCurrentPosition(position => {
        locationButton.style.display = 'inline';
        locationLoader.style.display = 'none';
        fetchedLocation = {lat: position.coords.latitude, lng: position.coords.longitude};

        const reverseGeocodeService = 'https://nominatim.openstreetmap.org/reverse';
        fetch(`${reverseGeocodeService}?format=jsonv2&lat=${fetchedLocation.lat}&lon=${fetchedLocation.lng}`)
            .then(response => response.json())
            .then(data => {
                locationInput.value = `${data.address.country}, ${data.address.state}`;
                document.querySelector('#manual-location').classList.add('is-focused');
            })
            .catch(error => {
                console.log(error);
                locationButton.style.display = 'inline';
                locationLoader.style.display = 'none';
                if (!sawAlert) {
                    alert('Couldn\'t fetch location, please enter manually!');
                    sawAlert = true;
                }
                fetchedLocation = {lat: 0, lng: 0};
            });
    }, error => {
        console.log(error);
        locationButton.style.display = 'inline';
        locationLoader.style.display = 'none';
        if (!sawAlert) {
            alert('Couldn\'t fetch location, please enter manually!');
            sawAlert = true;
        }
        fetchedLocation = {lat: 0, lng: 0};
    }, {timeout: 7000});
});
</code></pre>
                <h3>Testing</h3>

                <p>
                    Don't forget to run <code>npm run build</code> before <code>npm start</code> in order for the
                    service
                    worker to take into account the latest changes to the files
                </p>

                <p>
                    Testing on mobile requires <code>https</code>, so you need to deploy it to <strong>GitHub
                    Pages</strong> (have a look at the <em>Introduction to Service Workers</em> step 4 <em>Add to Home
                    Screen</em> if you don't have it set up) so run <code>npm run deploy</code>
                </p>

                <h2>Resources</h2>

                <ol>
                    <li>
                        <a href="https://developer.mozilla.org/en-US/docs/Web/API/Geolocation_API">
                            Geolocation API
                        </a>
                    </li>
                </ol>
            </google-codelab-step>
            <google-codelab-step label="Web Streams API" duration="5">
                <p>
                    The Web Streams API lets you stream content to your users. For example, say you want to display an
                    image on a web page. Without streaming, the following steps need to take place in the browser:
                </p>

                <ol>
                    <li>Fetch the image data from the network.</li>
                    <li>Process the data and uncompress it into raw pixel data.</li>
                    <li>Render the results to the page.</li>
                </ol>

                <p>
                    All these steps are critical to displaying an image, but why should you wait for the entire image to
                    be downloaded before you can start these steps? What if you could process the data piece by piece as
                    it was downloaded instead of waiting for the entire image to download? Without streaming, you need
                    to wait for the entire contents of the download to complete before you can return a response. But
                    using streaming you can return the results of the download and process it piece by piece, allowing
                    you to render something onto the screen even sooner. The great thing about this is that you can
                    process the result in parallel with fetching—much better.
                </p>

                <h2>Resources</h2>

                <ol>
                    <li>
                        <a href="https://developer.mozilla.org/en-US/docs/Web/API/Streams_API">Streams API</a>
                    </li>
                    <li>
                        <a href="https://jakearchibald.com/2016/streams-ftw/">Web Streams article</a>
                    </li>
                </ol>
            </google-codelab-step>
            <google-codelab-step label="Web Bluetooth API" duration="5">
                <p>
                    The <strong>Web Bluetooth API</strong> is a low-level API allowing Web applications to access the
                    services exposed by nearby Bluetooth-enabled devices.
                </p>

                <h2>API glimpse</h2>

                <ul>
                    <li>
                        <pre><code>navigator.bluetooth.requestDevice(serviceFilters)</code></pre>
                        <p>
                            Scans for the device in range supporting the requested services. Returns a
                            <code>Promise</code>.
                        </p>
                    </li>
                    <li>
                        <pre><code>device.gatt.connect()</code></pre>
                        <p>
                            Returns a <code>Promise</code> resolved with the server object providing access to the
                            services available on the device.
                        </p>
                    </li>
                    <li>
                        <pre><code>server.getPrimaryService(name)</code></pre>
                        <p>Returns a Promise resolved with the particular Bluetooth service on the device.</p>
                    </li>
                    <li>
                        <pre><code>service.getCharacteristic(name)</code></pre>
                        <p>
                            Returns a <code>Promise</code> resolved with the GATT characteristic object.
                        </p>
                    </li>
                    <li>
                        <pre><code>service.getCharacteristic(name)</code></pre>
                        <p>
                            Returns a <code>Promise</code> resolved with the GATT characteristic object.
                        </p>
                    </li>
                    <li>
                        <pre><code>characteristic.readValue()</code></pre>
                        <p>
                            Returns a <code>Promise</code> resolved with a raw value from the GATT characteristic.
                        </p>
                    </li>
                </ul>

                <h2>Example</h2>

                <h3>HTML</h3>

                <pre>
<code>
&lt;p&gt;
  &lt;button class="btn btn-lg btn-default" onclick="readBatteryLevel()">Read Bluetooth device's&lt;br&gt;battery level&lt;/button&gt;
&lt;/p&gt;

&lt;p id="target"&gt;&lt;/p&gt;
</code></pre>

                <h3>JavaScript</h3>

                <pre>
<code>
const readBatteryLevel = () => {
    const $target = document.getElementById('target');

    if (!('bluetooth' in navigator)) {
        $target.innerText = 'Bluetooth API not supported.';
        return;
    }

    navigator.bluetooth.requestDevice({
        filters: [{
            services: ['battery_service']
        }]
    })
        .then(device => device.gatt.connect())
        .then(server => server.getPrimaryService('battery_service'))
        .then(service => service.getCharacteristic('battery_level'))
        .then(characteristic => characteristic.readValue())
        .then((value) => {
            $target.innerHTML = 'Battery percentage is <b>' + value.getUint8(0) + '</b>.';
        })
        .catch((error) => {
            $target.innerText = error;
        });
};
</code></pre>

                <h2>Resources</h2>

                <ol>
                    <li>
                        <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Bluetooth_API">Web Bluetooth
                            API</a>
                    </li>
                    <li>
                        <a href="https://developers.google.com/web/updates/2015/07/interact-with-ble-devices-on-the-web">
                            Interact with Bluetooth devices on the Web
                        </a>
                    </li>
                </ol>
            </google-codelab-step>
            <google-codelab-step label="Web Share API" duration="5">
                <p>
                    There were several attempts to establish the universal, multi-platform, asynchronous way of data
                    exchange from the Web applications to native apps or nother Web apps and up to date no standardized
                    solution was conceived.
                </p>

                <p>
                    There are, however, some basic workarounds for sending data to nother applications. Native
                    applications can register handlers to receive data from the Web apps using special URL prefixes
                    (although differences exist between iOS and Android). There are also third-party non-standard
                    services that coordinate sharing data between Web applications.
                </p>

                <p>
                    Google Chrome 18 implemented the <strong>Web Intents</strong> experimental API. It was conceptually
                    based on Android Intents system. The apps interested in receiving data were required to be
                    registered in Chrome Web Store and declare the intent support in the manifest file. The apps sending
                    the data were able to invoke the Intent of the particular type and let the system handle the
                    selection of the target application and its proper invocation. The API was removed in Chrome 24
                    because of various interoperability and usability issues. No other vendor implemented Web Intents.
                </p>

                <p>
                    The newest implementation, <strong>Web Share API</strong>, as of September 2017 available in Chrome
                    on Android, is much simpler and consists of a method to invoke the platform-specific share mechanism
                    and is limited to sharing named URLs only. There is a complementary <strong>Web Share Target
                    API</strong> in an early design phase to allow registering Web applications as the share receivers.
                </p>

                <h2>API glimpse</h2>

                <ul>
                    <li>
                        <pre><code>navigator.share({name, title, url})</code></pre>
                        <p>
                            Invokes the system-defined application selection and data share dialog to send the named URL
                            to another application and returns a <code>Promise</code> resolved when the share was
                            successful.
                        </p>
                    </li>
                </ul>

                <h2>Example</h2>

                <h3>HTML</h3>

                <pre>
<code>
&lt;p&gt;
  &lt;button
    class="btn btn-lg btn-default"
    onclick="share()">
        Share PWA Selfies&lt;br&gt;with &lt;b&gt;Web Share&lt;/b&gt;
    &lt;/button&gt;
&lt;/p&gt;
</code></pre>

                <h3>JavaScript</h3>

                <pre>
<code>
const share = () => {
    if (!("share" in navigator)) {
        alert('Web Share API not supported.');
        return;
    }

    navigator.share({
        title: 'Progressive Selfies',
        text: 'Grab your duck face the PWA way',
        url: 'https://pwa.selfies/'
    })
    .then(() => console.log('Successful share'))
    .catch(error => console.log('Error sharing:', error));
};
</code></pre>
                <h2>Resources</h2>

                <ol>
                    <li>
                        <a href="https://developer.mozilla.org/en-US/docs/Web/API/Navigator/share">
                            Navigator.share
                        </a>
                    </li>
                    <li>
                        <a href="https://developers.google.com/web/updates/2016/09/navigator-share">
                            Introducing the Web Share API
                        </a>
                    </li>
                </ol>

            </google-codelab-step>
            <google-codelab-step label="Payment Request API" duration="5">
                <p>
                    The <strong>Payment Request API</strong> allows Web applications to delegate the payment checkout
                    process to the operating system, allowing it to use whatever methods and payment providers are
                    natively available for the platform and configured for the user. This approach takes away the burden
                    of handling complex checkout flows at the application side, reduces the scope of the payment
                    provider integration and ensures better familiarity for the user.
                </p>

                <p>
                    With <code>supportedMethods</code> parameter, the API allows the Web application to select the
                    supported payment methods - for example only to allow credit card payments or payments processed by
                    a specific 3rd-party provider - as well as configure its parameters. Methods are specified by the
                    predefined identifier or by the 3rd-party URL. Note that the behaviors of the payment methods might
                    vary. For example, the <code>basic-card</code> predefined provider does not process any actual
                    payments - its role is reduced to collecting the credit card details and returning it to the
                    requesting Web application although 3rd-party providers might as well proceed with the actual money
                    transfer as a part of the flow.
                </p>

                <p>
                    With <code>details</code> parameter, the Web application should specify the total amount and
                    currency
                    of the payment. It also allows setting up the order summary information including the subtotals,
                    order items, and shipping options.
                </p>

                <p>
                    With <code>options</code> parameter, the Web application might specify what kind of customer data it
                    requires to be able to fulfill the request. It may require a shipping address
                    (<code>requestShipping</code>), email (<code>requestPayerEmail</code>), phone (<code>requestPayerPhone</code>)
                    or name (<code>requestPayerName</code>).
                </p>

                <p>
                    The only payment method available on Apple devices is <a href="https://www.apple.com/apple-pay/">Apple
                    Pay</a>, and it is only functional on devices with fingerprint authentication (Touch ID). It is
                    accessible via the proprietary non-standard <code>ApplePaySession</code> API instead of the Payment
                    Request API described here. The support for standard Payment Request API in Safari is available from
                    Safari 11.1 on macOS and Safari on iOS 11.3.
                </p>

                <h2>API Glimpse</h2>

                <ul>
                    <li>
                        <pre><code>paymentRequest = new PaymentRequest({supportedMethods, details, options})</code></pre>
                        <p>
                            Creates a payment request object with the requested amounts, currencies and methods
                            configured.
                        </p>
                    </li>
                    <li>
                        <pre><code>paymentRequest.canMakePayment()</code></pre>
                        <p>
                            Returns a <code>Promise</code> resolved with the value indicating if it is possible to
                            conduct a payment using any of the supportedMethods specified.
                        </p>
                    </li>
                    <li>
                        <pre><code>paymentRequest.show()</code></pre>
                        <p>
                            Presents the checkout confirmation UI to the user or redirects to the system-defined
                            application that accepts payments by a method selected. Returns a <code>Promise</code>
                            resolved with the <code>response</code> object the payment provider successfully confirms
                            the payment. Note that it may or may not already denote the money being transferred
                            - it depends on the selected payment method implementation.
                        </p>
                    </li>
                    <li>
                        <pre><code>request.addEventListener('shippingaddresschange', listener)</code></pre>
                        <p>
                            An event fired when the user changes the shipping address data, allowing updating the
                            request's <code>details</code> using <code>event.updateWith()</code> method.
                        </p>
                    </li>
                    <li>
                        <pre><code>request.addEventListener('shippingoptionchange', listener)</code></pre>
                        <p>
                            An event fired when the user changes the shipping options (delivery vs. pickup etc.),
                            allowing updating the request's <code>details</code> using <code>event.updateWith()</code>
                            method.
                        </p>
                    </li>
                    <li>
                        <pre><code>event.updateWith(promise)</code></pre>
                        <p>
                            Waits for a <code>promise</code> to resolve with the new payment details and puts it into
                            the request's <code>details</code>.
                        </p>
                    </li>
                    <li>
                        <pre><code>response.toJSON()</code></pre>
                        <p>
                            A convenience method that serializes the payment response (including the requested payment
                            details and the data returned by the provider) into JSON intended to be sent to server-side
                            for order processing.
                        </p>
                    </li>
                    <li>
                        <pre><code>response.complete(result)</code></pre>
                        <p>
                            Signals the browser that the app-specific steps of payment processing (like sending the
                            order data to the server-side) have completed. Returns a <code>Promise</code> resolved when
                            the Payment Request UI is cleared.
                        </p>
                    </li>
                </ul>

                <h2>Example</h2>

                <h3>HTML</h3>

                <pre>
<code>
&lt;p&gt;
    &lt;button class="btn btn-default" onclick="donate()"&gt;
        Donate 10€
    &lt;/button&gt;
&lt;/p&gt;

&lt;p id="log"&gt;&lt;/p&gt;
</code></pre>

                <h3>JavaScript</h3>

                <pre>
<code>
const donate = () => {
    if (!window.PaymentRequest) {
        alert('This browser does not support Web Payments API');
        return;
    }

    let request = initPaymentRequest();
    onBuyClicked(request);
};

/**
 * Invokes PaymentRequest for credit cards.
 */
const onBuyClicked = request => {
    request.show()
        .then(instrumentResponse => sendPaymentToServer(instrumentResponse))
        .catch(err => document.getElementById('log').innerText = err);
};

/**
 * Simulates processing the payment data on the server.
 */
const sendPaymentToServer = instrumentResponse => {
    // There's no server-side component of these samples. No transactions are
    // processed and no money exchanged hands. Instantaneous transactions are not
    // realistic. Add a 2 second delay to make it seem more real.

    window.setTimeout(() => {
        instrumentResponse.complete('success')
            .then(() => document.getElementById('log').innerHTML = resultToTable(instrumentResponse))
            .catch(err => document.getElementById('log').innerText = err);
    }, 2000);
};

/**
 * Converts the payment instrument into a JSON string.
 */
const resultToTable = result => {
    return `&lt;table class="table table-striped"&gt;
        &lt;tr&gt;&lt;td&gt;Method name&lt;/td&gt;&lt;td&gt;${result.methodName}&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;Billing address&lt;/td&gt;&lt;td&gt;${(result.details.billingAddress || {}).addressLine}, ${(result.details.billingAddress || {}).city}&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;Card number&lt;/td&gt;&lt;td&gt;${result.details.cardNumber}&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;Security code&lt;/td&gt;&lt;td&gt;${result.details.cardSecurityCode}&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;Cardholder name&lt;/td&gt;&lt;td&gt;${result.details.cardholderName}&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;Expiry date&lt;/td&gt;&lt;td&gt;${result.details.expiryMonth}/${result.details.expiryYear}&lt;/td&gt;&lt;/tr&gt;
        &lt;/table&gt;`;
};
</code></pre>
                <h2>Resources</h2>

                <ol>
                    <li>
                        <a href="https://developer.mozilla.org/en-US/docs/Web/API/Payment_Request_API">
                            Payment Request API
                        </a>
                    </li>
                    <li>
                        <a href="https://developers.google.com/web/fundamentals/payments/">Web Payments Overview</a>
                    </li>
                    <li>
                        <a href="https://webkit.org/blog/8182/introducing-the-payment-request-api-for-apple-pay/">
                            Introducing the Payment Request API for Apple Pay
                        </a>
                    </li>
                </ol>
            </google-codelab-step>
            <google-codelab-step label="Shape Detection API" duration="5">
                <p>
                    The Shape Detection API gives developers access to features such as face detection,
                    barcode detection, and even text detection. This is great for the web.
                </p>

                <p>
                    To understand how you might use it in the real world, consider the following example. Imagine you
                    own a large shop that sells books. If you ever need to check the price of a book without a price
                    tag, you can walk to the register and scan the label to check the price. But if you had a PWA on
                    your mobile device with access to the prices of all the books, you could walk around the store using
                    your mobile device and the barcode detector to quickly and easily give you the price of the book.
                    This is just one example, but being able to detect shapes opens up a world of possibilities.
                </p>

                <p>
                    The following listing shows a basic example.
                </p>

                <h2>Example</h2>

                <h3>JavaScript</h3>

                <pre>
<code>
const barcodeDetector = new BarcodeDetector();

barcodeDetector.detect(image)
    .then(barcodes => {
        barcodes.forEach(barcode => console.log(barcodes.rawValue))
    })
    .catch(err => {
        console.log("Looks like something went wrong:", err);
    });
</code></pre>

                <h2>Resources</h2>

                <ol>
                    <li>
                        <a href="https://wicg.github.io/shape-detection-api/">Accelerated Shape Detection in Images</a>
                    </li>
                    <li>
                        <a href="https://paul.kinlan.me/face-detection/">Face detection using Shape Detection API</a>
                    </li>
                    <li>
                        <a href="https://paul.kinlan.me/barcode-detection/">
                            Barcode detection using Shape Detection API
                        </a>
                    </li>
                    <li>
                        <a href="https://paul.kinlan.me/detecting-text-in-an-image/">
                            Detecting text in an image on the web in real-time
                        </a>
                    </li>
                </ol>
            </google-codelab-step>
            <google-codelab-step label="Summary" duration="1">
                <p>
                    The Web Bluetooth API allows websites to communicate over GATT with nearby user-selected Bluetooth
                    devices in a secure and privacy-preserving way.
                </p>
                <p>
                    The Web Share API allows websites to invoke the native sharing capabilities of the host platform
                    directly from the web.
                </p>
                <p>
                    The Payment Request API is a system that aims to eliminate checkout forms by vastly improving the
                    user workflow during the purchase process and providing a more consistent user experience, enabling
                    web merchants to easily implement payment methods.
                </p>
                <p>
                    Modern browsers are capable of some amazing things: access to hardware features such as the user’s
                    geolocation, device vibration, and even battery status are already available via easy-to-access
                    APIs.
                </p>
                <p>
                    You can use the Shape Detection API to detect barcodes, text, and even faces inside images.
                </p>

                <h2>
                    <strong>What we've learned</strong>
                </h2>

                <p>
                    Here is a checklist which breaks down the things we learned in this code lab.
                </p>

                <ul class="checklist">
                    <li>Camera & Microphone</li>
                    <li>Geolocation</li>
                    <li>Web Streams API</li>
                    <li>Web Bluetooth API</li>
                    <li>Web Share API</li>
                    <li>Payment Request API</li>
                    <li>Shape Detection API</li>
                </ul>

                <h3>Source code</h3>

                <pre><code>$ git checkout pwa-beyond-final</code></pre>
            </google-codelab-step>
        </google-codelab>
    </template>
    <script>
        Polymer({
            is: 'codelab-beyond-pwas',

            _twoWayBinding: function (value) {
                return '{{' + value + '}}';
            },

            _oneWayBinding: function (value) {
                return '[[' + value + ']]';
            }
        });
    </script>
</dom-module>
